// -------------- Start Create plugins page

/**
@page creating_plugins_page How to create new plugins for KetaRoller

<p>
Creating new plugins for KetaRoller is easy. There should be a plugin for each of the three reimplementable classes (InputDevice,
OutputDevice and OutputPort). This section will cover how to create a plugin for each of this special cases. It is assumed that
you are confident with basic CMake and basic plugin concepts.
</p>

@section generic_plugin_info_sec Things to consider when creating a plugin

<p>
Differently from other Qt plugins, you <b>MUST NOT</b> use the Q_EXPORT_PLUGIN or Q_EXPORT_PLUGIN2 macro. This is automatically
done by the autogenerated files we'll talk about later in @ref create_plugins_cmake_sec "Adding the necessary bits to the build system".
</p><p>
Also, if you're not yet familiar with @ref generic_argument_model_sec "the generic argument model", please make sure to read the
related section before starting to code.
</p>

@section creating_input_device_plugin_sec Creating an InputDevice

<p>
To create an input device plugin, you need to reimplement KetaRoller::InputDevice in your class.
This is how the (basic) TUIO input device looks:
</p>

@code
class TuioInputDevice : public KetaRoller::InputDevice, public TUIO::TuioListener
{
    Q_OBJECT
    Q_INTERFACES(KetaRoller::InputDevice)

public:
    TuioInputDevice(QObject* parent = 0);
    virtual ~TuioInputDevice();

    virtual void addTuioCursor(TUIO::TuioCursor* tcur);
    virtual void addTuioObject(TUIO::TuioObject* tobj);

protected:
    virtual void init(const QVariantMap& args = QVariantMap());
    virtual bool validatePort(KetaRoller::InputPort* port);
};
@endcode

<p>Remember to use Q_INTERFACES. You probably want to reimplement init() to perform initialization on your plugin, and you
need to reimplement validatePort() to allow your device to accept only supported ports.
</p><p>
@c addTuioCursor is a TUIO specific callback, in which you need to create the data object and stream it to the correct port.
This is completely up to the device implementation: so inside your device you will need to call
KetaRoller::InputPort::putData() on the correct port to make the chain work correctly.
</p>

@section creating_output_port_plugin_sec Creating an OutputPort

<p>
To create an output port plugin, you need to reimplement KetaRoller::OutputPort in your class. Additionally, you will need to
implement an additional function as a <b>public slot</b> named @c receiveData. Failure in declaring it as a public slot
or with the correct name will prevent your plugin from working. This is how the (basic) TUIO output port looks:
</p>

@code
class TuioOutputPort : public KetaRoller::OutputPort
{
    Q_OBJECT
    Q_INTERFACES(KetaRoller::OutputPort)
public:
    TuioOutputPort(QObject *parent);
    virtual ~TuioOutputPort();

public slots:
    void receiveData(const FiducialObject &message);

};
@endcode

<p>Remember to use Q_INTERFACES. Have a look at how receiveData is implemented here - FiducialObject is the type which is
used in the TUIO message chain.
</p><p>
In receiveData, you will need to (eventually) process the received data and (eventually) stream it to the device. This is
done by calling KetaRoller::OutputPort::sendDataToDevice(). Remember that you need explicitely to call this function whenever needed.
</p>

@section creating_output_device_plugin_sec Creating an OutputDevice

<p>
To create an output device plugin, you need to reimplement KetaRoller::OutputDevice in your class. Additionally, you will need to
implement an additional function as a <b>public slot</b> named @c newDataFromPort. Failure in declaring it as a public slot
or with the correct name will prevent your plugin from working. This is how a (basic) sound output device looks:
</p>

@code
class SoundOutputDevice : public KetaRoller::OutputDevice
{
    Q_OBJECT
    Q_INTERFACES(KetaRoller::OutputDevice)
public:
    SoundOutputDevice(QObject* parent = 0);
    virtual ~SoundOutputDevice();

    virtual void init(const QVariantMap& args = QVariantMap());
    virtual bool validatePort(KetaRoller::OutputPort* port);

public slots:
    void newDataFromPort(KetaRoller::OutputPort *port, const FiducialObject &obj);

};
@endcode

<p>Remember to use Q_INTERFACES. Have a look at how @c newDataFromPort is implemented here - FiducialObject is the type which is
used in the TUIO message chain. Also, remember that the first argument should @b ALWAYS be KetaRoller::OutputPort* - complete
with namespace in the exported symbol.
</p><p>
In @c newDataFromPort, you have to process the data which you received from the specified port as you please.
</p><p>
Differently from ports, OutputDevices can accept multiple protocols on their ends. Supposing you want your OutputDevice
to accept both MIDI and TUIO, you would overload newDataFromPort in the following way:
</p>
@code
public slots:
    void newDataFromPort(KetaRoller::OutputPort *port, const FiducialObject &obj);
    void newDataFromPort(KetaRoller::OutputPort *port, const MIDIMessage &msg);
@endcode
<p>
Done that, you can handle independently TUIO and MIDI messages in your device by implementing both functions.
</p>

@section create_plugins_cmake_sec Adding the necessary bits to the build system

@note This applies to all kinds of plugins

<p>
KetaRoller features a very easy method to create plugins through CMake. A CMake macro named \c add_ketaroller_plugin is provided
to export plugins. This macro autogenerates a PluginFactory for your plugin; you just need to add the generated file to your
project's sources to make it work. This is how TUIO's buildsystem looks like:
</p>

@code
include_directories(
    ${CMAKE_CURRENT_BINARY_DIR}
    ${CMAKE_CURRENT_SOURCE_DIR}
)

include(KetaRollerPlugin)

add_ketaroller_plugin("TUIO" "TuioInputDevice.h" "InputDevice" "TuioInputDevice")
set(tuio_input_device_plugin_SRCS
    TuioInputDevice.cpp
    FiducialObject.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/TUIOInputDeviceFactory.cpp
)

automoc4_add_library(ketaroller_tuio_input_device SHARED ${tuio_input_device_plugin_SRCS})
target_link_libraries(ketaroller_tuio_input_device ketaroller tuio ${QT_QTGUI_LIBRARY})
@endcode

<p>
The macro takes 4 arguments, in order:

<ul>
    <li>The name of the plugin, which will be the prefix of the generated file. In this case, @c TUIO .</li>
    <li>The header file containing the plugin class itself, so in this case the file containing TuioInputDevice,
        @c TuioInputDevice.h .</li>
    <li>The class we are reimplementing @b WITHOUT the KetaRoller namespace, in this case @c InputDevice .</li>
    <li>The name of the class of our plugin, in this case @c TuioInputDevice .</li>
</ul>

So the name of the generated file is $FIRSTARGUMENT$THIRDARGUMENTFactory.cpp, and it is generated inside
${CMAKE_CURRENT_BINARY_DIR}. So adding it to your project's sources is enough to have your plugin ready.
</p>

@note Please note that the autogenerated files already include Q_EXPORT_PLUGIN2, so you should not use it in your sources.
*/
