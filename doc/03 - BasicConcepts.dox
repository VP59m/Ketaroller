// -------------- Start Basic concepts page

/**
@page basic_concepts_page Basic concepts and models used in KetaRoller

<p>
KetaRoller uses some advanced techniques in conjunction with Qt to achieve some of its advanced
features, such as runtime data introspection, data routing, non strongly-typed methods and such.
</p>

@section plugin_factory_model_sec The plugin factory model

<p>
In KetaRoller, every routing component, except for InputPort, is a plugin which is dynamically loaded at runtime
if needed. However, given that most of the times you need to load more than an instance of a single plugin (this is
especially true for ports), exporting the main class itself as a plugin wouldn't have worked, as the exported symbol
could be loaded from the shared library only once, thus generating a single instance.
</p><p>
For this reason, an helper class has been created, AbstractPluginFactory. This class is what gets really exported, and
allows to create n instances of the plugin on demand. This mechanism is internal and completely transparent to both the
final user of the library and programmer who wants to implement a new plugin.
</p><p>
If you are using KetaRoller in your application, PluginLoader will take care of all the needed magic for getting you
an instance of the requested class ready to be used.
</p><p>
If you are implementing a new plugin, you just have to take care of implementing the main class: the factory will be
autogenerated by the build system through a cmake macro which handles the factory creation. This is explained in detail
in @ref create_plugins_cmake_sec "Creating plugins - Adding the necessary bits to the build system"
</p>


@section routing_model_sec Routing in KetaRoller

<p>
KetaRoller uses a 4-phase, modular routing to ensure the maximum flexibility for the programmer, without forgetting
the ease of use. It consists of four main components:
</p>

<ul>
    <li>InputDevice: The first element in the chain. It has to be reimplemented in a plugin. It takes care of
        validating ports and sending data to the correct input ports. It can contain an arbitrary number of
        InputPorts. Usually, it's an implementation of a real world device, such as reactivision.</li>
    <li>InputPort: Ports which takes care of opening a sort of tunnel from an InputDevice to an OutputDevice. An
        input port can be associated to a single InputDevice, and connected to an arbitrary number of OutputPorts.
        It takes care of routing the data to the output ports.</li>
    <li>OutputPort: Ports which takes care of receiving data and streaming it to its associated device. It has to
        be reimplemented in a plugin. It can be connected to a single InputPort and to a single OutputDevice. The
        port can work as a transparent bridge such as InputPort, or do some processing before streaming the data to
        the device. It's up to the programmer to decide how to implement this - however, it does not affect usage
        of the library.</li>
    <li>OutputDevice: The last element in the chain. It has to be reimplemented in a plugin. It takes care of
        validating ports and receiving data from its OutputPorts. It can contain an arbitrary number of
        OutputPorts. Usually, it's an implementation of a real world output device, such as a synthesizer.</li>
</ul>

<p>
So, a signal received from an InputDevice is routed to an OutputDevice through Ports. It's up to the programmer to decide
what ports should represent: usually, each port represents a single mean of communication of the device - for example, a
TUIO fiducial or a MIDI channel - but you might decide to use a single port to route all the traffic.
</p><p>
This architecture aims to provide a full loosely coupled system for routing signals, which is not even bound to what
a Port/Device combination supports: the developer is completely in control of each and every connection between Ports and Devices.
To the bottom line: the developer can couple any combination of devices. Here is a small schema of the routing chain:
</p>
@image latex routing_chain_graph.png "KetaRoller's routing chain" width=250px
<p>
When using the library and not implementing a plugin, the routing phase is started whenever the device receives data and it's
all processed internally - so you have nothing to do except connecting ports and associating them to devices.
</p>

@section generic_argument_model_sec The Generic Argument model

<p>
KetaRoller uses Qt's metaobjects capabilities to let different ports exchange arbitrary data in an
abstract way. Instead of using reimplementations of strongly-typed functions, KetaRoller uses QGenericArgument
in conjunction with QMetaObject::invokeMethod to call a callback defined in the plugin reimplementation with
the correct argument. Let's see an example to understand how this works.
</p><p>
Let's assume we are implementing an OutputPort, and our Input/Output chain in done through a custom data type
defined by \c MyDataType.
As explained in @ref creating_output_port_plugin_sec "creating an OutputPort",
we need to implement a function named receiveData in our class, which would look like:
</p>

@code
class MyOutputPort : public KetaRoller::OutputPort
{
    Q_OBJECT
public:
    MyOutputPort(QObject *parent = 0);
    virtual ~MyOutputPort();

public slots:
    void receiveData(const MyDataType &type);
}
@endcode

Done this, we'll need to declare MyDataType as a metatype known to Qt's metaobject system. To do that, we need to put
the following declaration

@code
Q_DECLARE_METATYPE(MyDataType)
@endcode

in an header of our project - be it the same header of the output port or (even better) the header of the file where the
type is defined.
<p>
This is enough to get our system working. Let's see what happens when calling the following snippet on an input port
connected to an instance of the output port we just created.
</p>

@code
MyDataType data = MyDataType::createNewFromRandomArguments();
inputPort->putData(Q_ARG(MyDataType, data));
@endcode

<p>
As you see, generating QGenericArgument happens through the Q_ARG macro, which accepts the type itself, and the instance
we want to pass as the argument. Internally, InputPort uses Qt's runtime introspection through QMetaObject::invokeMethod
to call the method with the correct signature on the receiver object.
</p><p>
Obviously, this method will work only if the signature of the slot corresponds to the type passed to Q_ARG(). For this
reason, it's impossible for a port to receive a type of data which does not know how to handle. This adds additional security
to the whole process, making the port not strongly-typed, but still type-safe on reception.
</p>

*/
