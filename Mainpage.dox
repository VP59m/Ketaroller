/**
@mainpage KetaRoller - an advanced signal router for musical devices

KetaRoller is a signal router which is able to route arbitrary data between devices.

 - @subpage basic_concepts_page "Basic concepts and models used in KetaRoller"
 - @subpage ketaroller_usage_page "How to use KetaRoller in your application"
 - @subpage creating_plugins_page "How to create new plugins for KetaRoller"
 - @subpage plugin_specific_documentation_page "Plugin-specific documentation (arguments, advices...)"

*/

// -------------- Start Basic concepts page

/**
@page basic_concepts_page Basic concepts and models used in KetaRoller

<p>
KetaRoller uses some advanced techniques in conjunction with Qt to achieve some of its advanced
features, such as runtime data introspection, data routing, non strongly-typed methods and such.
</p>

@section plugin_factory_model_sec The plugin factory model

<p>
In KetaRoller, every routing component, except for InputPort, is a plugin which is dynamically loaded at runtime
if needed. However, given that most of the times you need to load more than an instance of a single plugin (this is
especially true for ports), exporting the main class itself as a plugin wouldn't have worked, as the exported symbol
could be loaded from the shared library only once, thus generating a single instance.
</p><p>
For this reason, an helper class has been created, AbstractPluginFactory. This class is what gets really exported, and
allows to create n instances of the plugin on demand. This mechanism is internal and completely transparent to both the
final user of the library and programmer who wants to implement a new plugin.
</p><p>
If you are using KetaRoller in your application, PluginLoader will take care of all the needed magic for getting you
an instance of the requested class ready to be used.
</p><p>
If you are implementing a new plugin, you just have to take care of implementing the main class: the factory will be
autogenerated by the build system through a cmake macro which handles the factory creation. This is explained in detail
in @ref create_plugins_cmake_sec "Creating plugins - Adding the necessary bits to the build system"
</p>


@section routing_model_sec Routing in KetaRoller

<p>
KetaRoller uses a 4-phase routing to ensure the maximum flexibility for the programmer, without forgetting
the ease of use. It consists of four main components:
</p>

<ul>
    <li>InputDevice: The first element in the chain. It has to be reimplemented in a plugin. It takes care of
        validating ports and sending data to the correct input ports. It can contain an arbitrary number of
        InputPorts. Usually, it's an implementation of a real world device, such as reactivision.</li>
    <li>InputPort: Ports which takes care of opening a sort of tunnel from an InputDevice to an OutputDevice. An
        input port can be associated to a single InputDevice, and connected to an arbitrary number of OutputPorts.
        It takes care of routing the data to the output ports.</li>
    <li>OutputPort: Ports which takes care of receiving data and streaming it to its associated device. It has to
        be reimplemented in a plugin. It can be connected to a single InputPort and to a single OutputDevice. The
        port can work as a transparent bridge such as InputPort, or do some processing before streaming the data to
        the device. It's up to the programmer to decide how to implement this - however, it does not affect usage
        of the library.</li>
    <li>OutputDevice: The last element in the chain. It has to be reimplemented in a plugin. It takes care of
        validating ports and receiving data from its OutputPorts. It can contain an arbitrary number of
        OutputPorts. Usually, it's an implementation of a real world output device, such as a synthesizer.</li>
</ul>

<p>
So, a signal received from an InputDevice is routed to an OutputDevice through Ports. It's up to the programmer to decide
what ports should represent: usually, each port represents a single mean of communication of the device - for example, a
TUIO fiducial or a MIDI channel - but you might decide to use a single port to route all the traffic.
</p><p>
When using the library and not implementing a plugin, the routing phase is started whenever the device receives data and it's
all processed internally - so you have nothing to do except connecting ports and associating them to devices.
</p>

@section generic_argument_model_sec The Generic Argument model

<p>
KetaRoller uses Qt's metaobjects capabilities to let different ports exchange arbitrary data in an
abstract way. Instead of using reimplementations of strongly-typed functions, KetaRoller uses QGenericArgument
in conjunction with QMetaObject::invokeMethod to call a callback defined in the plugin reimplementation with
the correct argument. Let's see an example to understand how this works.
</p><p>
Let's assume we are implementing an OutputPort, and our Input/Output chain in done through a custom data type
defined by \c MyDataType.
As explained in @ref creating_output_port_plugin_sec "creating an OutputPort",
we need to implement a function named receiveData in our class, which would look like:
</p>

@code
class MyOutputPort : public KetaRoller::OutputPort
{
    Q_OBJECT
public:
    MyOutputPort(QObject *parent = 0);
    virtual ~MyOutputPort();

public slots:
    void receiveData(const MyDataType &type);
}
@endcode

Done this, we'll need to declare MyDataType as a metatype known to Qt's metaobject system. To do that, we need to put
the following declaration

@code
Q_DECLARE_METATYPE(MyDataType)
@endcode

in an header of our project - be it the same header of the output port or (even better) the header of the file where the
type is defined.
<p>
This is enough to get our system working. Let's see what happens when calling the following snippet on an input port
connected to an instance of the output port we just created.
</p>

@code
MyDataType data = MyDataType::createNewFromRandomArguments();
inputPort->putData(Q_ARG(MyDataType, data));
@endcode

<p>
As you see, generating QGenericArgument happens through the Q_ARG macro, which accepts the type itself, and the instance
we want to pass as the argument. Internally, InputPort uses Qt's runtime introspection through QMetaObject::invokeMethod
to call the method with the correct signature on the receiver object.
</p><p>
Obviously, this method will work only if the signature of the slot corresponds to the type passed to Q_ARG(). For this
reason, it's impossible for a port to receive a type of data which does not know how to handle. This adds additional security
to the whole process, making the port not strongly-typed, but still type-safe on reception.
</p>

*/

// -------------- Start Usage page

/**
@page ketaroller_usage_page How to use KetaRoller in your application

<p>
Using KetaRoller in your application is extremely simple. Some examples are already provided in tests/manual, but this page
will explain how to connect a TUIO InputDevice and a MIDI InputDevice to an output device which we will name "SoundDevice" and
will assume existent, working, and accepting both MIDI and TUIO OutputPorts. Let's see how to do this.
</p>

@section instantiating_objects_usage_sec Instantiating the needed objects through PluginLoader and connecting the ports

<p>
First of all, we'll need to create our devices. We will assume an instance of our output device has already been created.
</p><p>
We want to create a MIDI device and a TUIO device, 3 TUIO ports (both input and output) and a single MIDI port.
To do this, we need to use PluginLoader. PluginLoader is the main entry point for creating objects from plugins. Let's
see it in action (m_tuioOutputs is a QHash<OutputPort*, int>, and so is m_tuioInputs):
</p>

@code
using namespace KetaRoller;

m_tuioInputDevice = PluginLoader::instance()->loadInputDevice(KetaRoller::PluginLoader::TuioType);
m_midiInputDevice = PluginLoader::instance()->loadInputDevice(KetaRoller::PluginLoader::MIDIType);

m_outputDevice = new SoundDevice();

for (int i = 0; i < 3; ++i) {
    OutputPort *port = PluginLoader::instance()->loadOutputPort(KetaRoller::PluginLoader::TuioType);
    m_outputDevice->addIncomingPort(port);
    m_tuioOutputs.insert(port, i);
}

m_midiOutput = PluginLoader::instance()->loadOutputPort(KetaRoller::PluginLoader::MIDIType);
m_outputDevice->addIncomingPort(m_midiOutput);

for (int i = 0; i < 3; ++i) {
    QVariantMap args;
    args.insert("TuioFiducialID", i);

    KetaRoller::InputPort *input = new InputPort(KetaRoller::Port::TUIOType, args);

    m_tuioInputDevice->addOutgoingPort(input);

    input->addOutput(m_outputs.key(i));

    m_tuioInputs.insert(input, i);
}

m_midiInput = new InputPort(KetaRoller::Port::MIDIType);
m_midiInput->addOutput(m_midiOutput);
@endcode

<p>As you can see, it's very easy to use PluginLoader to load the needed instances. InputPort, though, acts as a
transparent proxy, hence it's not reimplemented anywhere and can be created as a standard object, specifying the port
type.
</p><p>
While initializing our objects, we also connected the ports through InputPort::addOutput.
</p>

@section finalizing_usage_sec Maintainance of the created chain

Once the initialization has been completed, the chain is already working by itself: the InputDevices take care of routing
any input signal received through their ports, and the OutputDevice processes them as it should. However, you can monitor
the ports through portAdded and portRemoved signals, and disconnect them. It is advised to disconnect the ports through InputDevice
unless you have specific needs. Please refer to the class documentation of InputDevice to learn more on that.



*/

// -------------- Start Create plugins page

/**
@page creating_plugins_page How to create new plugins for KetaRoller

<p>
Creating new plugins for KetaRoller is easy. There should be a plugin for each of the three reimplementable classes (InputDevice,
OutputDevice and OutputPort). This section will cover how to create a plugin for each of this special cases. It is assumed that
you are confident with basic CMake and basic plugin concepts.
</p>

@section generic_plugin_info_sec Things to consider when creating a plugin

<p>
Differently from other Qt plugins, you <b>MUST NOT</b> use the Q_EXPORT_PLUGIN or Q_EXPORT_PLUGIN2 macro. This is automatically
done by the autogenerated files we'll talk about later in @ref create_plugins_cmake_sec "Adding the necessary bits to the build system".
</p><p>
Also, if you're not yet familiar with @ref generic_argument_model_sec "the generic argument model", please make sure to read the
related section before starting to code.
</p>

@section creating_input_device_plugin_sec Creating an InputDevice

<p>
To create an input device plugin, you need to reimplement KetaRoller::InputDevice in your class.
This is how the (basic) TUIO input device looks:
</p>

@code
class TuioInputDevice : public KetaRoller::InputDevice, public TUIO::TuioListener
{
    Q_OBJECT
    Q_INTERFACES(KetaRoller::InputDevice)

public:
    TuioInputDevice(QObject* parent = 0);
    virtual ~TuioInputDevice();

    virtual void addTuioCursor(TUIO::TuioCursor* tcur);
    virtual void addTuioObject(TUIO::TuioObject* tobj);

protected:
    virtual void init(const QVariantMap& args = QVariantMap());
    virtual bool validatePort(KetaRoller::InputPort* port);
};
@endcode

<p>Remember to use Q_INTERFACES. You probably want to reimplement init() to perform initialization on your plugin, and you
need to reimplement validatePort() to allow your device to accept only supported ports.
</p><p>
@c addTuioCursor is a TUIO specific callback, in which you need to create the data object and stream it to the correct port.
This is completely up to the device implementation: so inside your device you will need to call InputPort::putData on the correct
port to make the chain work correctly.
</p>

@section creating_output_port_plugin_sec Creating an OutputPort

<p>
To create an output port plugin, you need to reimplement KetaRoller::OutputPort in your class. Additionally, you will need to
implement an additional function as a <b>public slot</b> named @c receiveData. Failure in declaring it as a public slot
or with the correct name will prevent your plugin from working. This is how the (basic) TUIO output port looks:
</p>

@code
class TuioOutputPort : public KetaRoller::OutputPort
{
    Q_OBJECT
    Q_INTERFACES(KetaRoller::OutputPort)
public:
    TuioOutputPort(QObject *parent);
    virtual ~TuioOutputPort();

public slots:
    void receiveData(const FiducialObject &message);

};
@endcode

<p>Remember to use Q_INTERFACES. Have a look at how receiveData is implemented here - FiducialObject is the type which is
used in the TUIO message chain.
</p><p>
In receiveData, you will need to (eventually) process the received data and (eventually) stream it to the device. This is
done by calling OutputPort::sendDataToDevice(). Remember that you need explicitely to call this function whenever needed.
</p>

@section creating_output_device_plugin_sec Creating an OutputDevice

<p>
To create an output device plugin, you need to reimplement KetaRoller::OutputDevice in your class. Additionally, you will need to
implement an additional function as a <b>public slot</b> named @c newDataFromPort. Failure in declaring it as a public slot
or with the correct name will prevent your plugin from working. This is how a (basic) sound output device looks:
</p>

@code
class SoundOutputDevice : public KetaRoller::OutputDevice
{
    Q_OBJECT
    Q_INTERFACES(KetaRoller::OutputDevice)
public:
    SoundOutputDevice(QObject* parent = 0);
    virtual ~SoundOutputDevice();

    virtual void init(const QVariantMap& args = QVariantMap());
    virtual bool validatePort(KetaRoller::OutputPort* port);

public slots:
    void newDataFromPort(KetaRoller::OutputPort *port, const FiducialObject &obj);

};
@endcode

<p>Remember to use Q_INTERFACES. Have a look at how @c newDataFromPort is implemented here - FiducialObject is the type which is
used in the TUIO message chain. Also, remember that the first argument should @b ALWAYS be KetaRoller::OutputPort* - complete
with namespace in the exported symbol.
</p><p>
In @c newDataFromPort, you have to process the data which you received from the specified port as you please.
</p>

@section create_plugins_cmake_sec Adding the necessary bits to the build system

@note This applies to all kinds of plugins

<p>
KetaRoller features a very easy method to create plugins through CMake. A CMake macro named \c add_ketaroller_plugin is provided
to export plugins. This macro autogenerates a PluginFactory for your plugin; you just need to add the generated file to your
project's sources to make it work. This is how TUIO's buildsystem looks like:
</p>

@code
include_directories(
    ${CMAKE_CURRENT_BINARY_DIR}
    ${CMAKE_CURRENT_SOURCE_DIR}
)

include(KetaRollerPlugin)

add_ketaroller_plugin("TUIO" "TuioInputDevice.h" "InputDevice" "TuioInputDevice")
set(tuio_input_device_plugin_SRCS
    TuioInputDevice.cpp
    FiducialObject.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/TUIOInputDeviceFactory.cpp
)

automoc4_add_library(ketaroller_tuio_input_device SHARED ${tuio_input_device_plugin_SRCS})
target_link_libraries(ketaroller_tuio_input_device ketaroller tuio ${QT_QTGUI_LIBRARY})
@endcode

<p>
The macro takes 4 arguments, in order:

<ul>
    <li>The name of the plugin, which will be the prefix of the generated file. In this case, @c TUIO .</li>
    <li>The header file containing the plugin class itself, so in this case the file containing TuioInputDevice,
        @c TuioInputDevice.h .</li>
    <li>The class we are reimplementing @b WITHOUT the KetaRoller namespace, in this case @c InputDevice .</li>
    <li>The name of the class of our plugin, in this case @c TuioInputDevice .</li>
</ul>

So the name of the generated file is $FIRSTARGUMENT$THIRDARGUMENTFactory.cpp, and it is generated inside
${CMAKE_CURRENT_BINARY_DIR}. So adding it to your project's sources is enough to have your plugin ready.
</p>

@note Please note that the autogenerated files already include Q_EXPORT_PLUGIN2, so you should not use it in your sources.
*/

// -------------- Start Plugin specific documentation page

/**
@page plugin_specific_documentation_page Plugin-specific documentation (arguments, advices...)

<p>
In this page the specific usages of the MIDI and TUIO plugins will be described
</p>

@section plugins_init_arguments_sec Plugin arguments

<p>Some plugins need additional arguments when created. Follows a list of the valid keys to pass to args with the expected value
for both plugins.</p>

@subsection tuio_plugins_init_arguments_sec TUIO plugins

@subsubsection tuio_input_port_init_arguments_sec Input Port

<ul>
    <li>@c TuioFiducialID : Represents the ID of the fiducial this port will listen to. Value should be an int > 0. <b>This
        parameters is compulsory</b></li>
</ul>
*/
