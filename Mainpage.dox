/**
@mainpage KetaRoller - an advanced signal router for musical devices

KetaRoller is a signal router which is able to route arbitrary data between devices, developed by Dario Freddi and Luca Mucci.

 - @subpage introduction_page "Introduction to the KetaRoller project"
 - @subpage design_choices_page "Design choices and 3rd party frameworks used by KetaRoller"
 - @subpage basic_concepts_page "Basic concepts and models used in KetaRoller"
 - @subpage ketaroller_usage_page "How to use KetaRoller in your application"
 - @subpage creating_plugins_page "How to create new plugins for KetaRoller"
 - @subpage plugin_specific_documentation_page "Plugin-specific documentation (arguments, advices...)"

*/

// -------------- Start Introduction page

/**
@page introduction_page Introduction to the KetaRoller project

<p>
This document will give an overview over the concepts, the design choices and the implementation details
behind KetaRoller, an advanced signal router for musical devices.
</p>

@image latex ketaroller_schema.png "KetaRoller's internal design overview" width=400px

@section main_intro_sec What is KetaRoller and where we are at

<p>
KetaRoller can be seen as a router for musical signals. It takes care of carrying a signal from one end to another - it
has nothing to do with signal processing. Its main aim is to allow connections between arbitrary devices which use the
same protocols through a set of "Ports" which are able to seize input signals in more specific and understandable parts.
</p><p>
Despite KetaRoller being completely multiplatform, this release will support Linux only. Building on Mac and Windows is possible,
but no warranties or support are given on those two platforms, so <b>do this at your own risk!</b>.
At least Mac will be fully supported in the near future.
</p>

@section protocol_overview_sec Protocols used by KetaRoller
<p>
KetaRoller aims towards full abstraction, as it will be explained later - in this project, two protocols were implemented:
</p>

<ul>
    <li><b>MIDI (Musical Instrument Digital Interface)</b>. An industry standard protocol for musical instrument
           communication. See @ref midi_protocol_sec "MIDI explained" for a better overview.</li>
    <li><b>TUIO</b>. A protocol for table-top tangible user interfaces based on OpenSoundControl. See
        @ref tuio_protocol_sec "TUIO explained" for a better overview.</li>
</ul>

@section bachelor_thesis_overview_sec KetaRoller in our Bachelor's thesis project
<p>
This project is a part of the big picture in our bachelor's thesis project, where we will implement a full-fledged
ReacTable (developed by MTG of Universit√† Pompeu Fabra, Barcelona) which will communicate with the sound synthesis
system BCT (developed by ISPG of Politecnico di Milano) throughout this very project. The final aim is to play/control
a musical instrument, created with this particular synthesis method, through a simple MIDI controller and ReacTable.
</p>
<p>
Given that ReacTable communicates through TUIO, as a first step we need to implement a software capable of handling
both protocols: this software should be able to receive packets, extract information through the use of the protocol
standard, and be able to provide concrete data to an output device (which will be the BCT - in this project, we will
use some fake output devices for printing messages for testing purposes).
</p>

@section tests_keta_sec Test cases and examples
<p>
We provided a set of autotests and manual test/examples in the tests/ folder. You can run the three autotests for checking
KetaRoller and its plugins' correct operation and check against regressions, and the two tests in manual/ for trying KetaRoller with
reacTIVision... and have some fun with fiducials!
</p>
*/

// -------------- Start Design choices and 3rd party frameworks used by KetaRoller

/**
@page design_choices_page Design choices and 3rd party frameworks used by KetaRoller

<p>
KetaRoller uses a wide variety of frameworks and concepts for bringing to the table its advanced features.
</p>

@section design_choices_sec Design choices

<p>
Some important decisions had to be taken before coding to ensure the quality of the product would have met the
expectation for the rest of the project. We will talk just about the concepts and the reasoning behind those choices -
you can find some technical explaination and implementation details in the next sections, especially
@ref basic_concepts_page "Basic concepts and models used in KetaRoller".
</p>

@subsection abstract_io_sec Full I/O abstraction

<p>
To provide developers with a very easy to use library, we developed a full abstract system which allows to plug in
any possible type of protocol/device, giving also future-proof warranty to KetaRoller's users. Should a new protocol
be born, the internal logic of KetaRoller can still work simply by writing a new set of plugins which use the new protocol.
</p>
<p>
This kind of abstraction also allows different protocol sources to connect to the same output device (given it accepts them).
For example, BCT will be capable of handling MIDI and TUIO: this will happen in a completely transparent way for the programmer,
which will just have to connect its MIDI and TUIO outputs to the chosen device ports.
</p>

@section frameworks_sec Frameworks used in KetaRoller

@subsection qt_framework_sec Qt by Nokia - the foundations of KetaRoller

<p>
KetaRoller is nothing but a Qt library, which relies heavily on Qt's advanced features to achieve many of its advanced
features. Qt is a multi-platform and multi-device library developed by Nokia, which is the foundation of many projects, both
commercial (Mathematica, Google Earth...) and many open source projects (KDE, MeeGo...).
</p>
<p>
Qt is distributed with a dual licensing system - we chose the open source LGPL license for our project, which will be released
under the same license as well.
</p>

@subsubsection qt_metaobject_sec The metaobject system

<p>
One of the main advantages of Qt over other C++ frameworks such as Boost is its runtime introspection features and its metaobject
features. Qt allows programmers to use non strongly-typed methods and runtime connections between objects, which
are the foundation of our @ref routing_model_sec "routing model".
</p><p>
This is achieved through a system named moc, which generates metaobject information at build time and allows runtime introspection.
This is completely transparent to the developer, which can even ignore the exsistence of moc, especially when developing with
CMake and automoc4. Surely, the metaobject features have been a primary reason for using Qt in the first place.
</p>

@subsubsection qt_gui_sec GUI framework

<p>
Qt was born as a GUI library, and it is still an awesome framework for generating user interfaces which look native on every
system. This, again, was a huge factor in chosing Qt due to our big picture: a GUI for controlling KetaRoller will be provided
in the near future.
</p>

@subsubsection qt_test_sec Test case framework

<p>
Qt also provides a full-fledged test case library for examples and autotests generation, and for creating benchmarks. This
allowed us to create easily a small set of autotests (to be used in conjunction with CMake's ctest suite) and a set of manual
tests/examples to show KetaRoller in action.
</p>

@subsubsection qt_touch_interfaces_sec Touch interfaces support

<p>
Given its future on mobile devices, Qt has recently acquired great support for touch-based interfaces and devices, including
a gesture recognizer and a full set of gestures event. We will use this feature for handling cursors in TUIO in the near future,
translating cursors to Qt gesture events and making Qt recognize which kind of gesture the user has done on the ReacTable surface.
</p><p>
This thing will open the door for using KetaRoller even on small touch screen devices, such as new generation mobile phones,
using a touch screen instead of a ReacTable as one of the main controllers.
</p>

@subsection cmake_build_system_sec The CMake buildsystem

<p>
CMake is an advanced, modular, and multiplatform build system which is used for building KetaRoller. Its ease and modularity
helped us a lot, especially when creating plugins. As explained in @ref plugin_factory_model_sec "the plugin factory model",
we created a new CMake macro which allows the developer to autogenerate the needed bits for making plugin work through a single
line in its buildsystem.
</p><p>
CMake also allows us to build KetaRoller on different platforms than Linux, such as Windows and Mac, and greatly supports
out-of-source builds.
</p>

@subsubsection cmake_ctest_sec Using CMake for autotests, packaging and generating this document

<p>
CMake also features Doxygen support through a module, and two components, namely CPack and CTest, for packaging
a project and running a set of existent tests in an automatic way. Our tests folder features CTest support, so once
you built KetaRoller, you can simply enter "ctest" in your terminal while in the binary tests directory to start the
test suite and see the results.
</p><p>
You can also create a new source release by entering "make package" in the root build folder.
</p>

@subsection midi_protocol_sec The MIDI protocol
<p>
MIDI (Musical Instrument Digital Interface) is an industry-standard protocol defined in 1982 that enables electronic
musical instruments such as keyboard controllers, synthetizers and computers, to communicate, control and synchronize with each other.
</p><p>
We need MIDI to trigger the sound production of BCT system: for example, if the sound modelled by the BCT is a percussion,
a MIDI percussion controller is very useful to trigger the sound.
</p>

@subsubsection rtmidi_framework_sec RtMidi - a multiplatform C++ framework

<p>
RtMidi is a C++ framework developed by Gary P. Scavone (McGill University) that provides a common API for realtime
MIDI input/output across Linux, Macintosh OS X and Windows operating systems.
</p><p>
RtMidi significantly simplifies the process of interacting with computer MIDI hardware and software, and it is designed to
be object oriented and cross-platform.<br />
For our project we use RtMidiIn facilities to receive MIDI messages with our MIDIInputDevice class.
</p><p>
Just 4 types of incoming MIDI message are accepted: NoteOn, NoteOff, PitchBender and ControlChange (they're enough for our purpose).
System exclusive, timing, active sensing, program change and bank change messages are ignored.
</p><p>
For further info please visit <a href="http://www.music.mcgill.ca/~gary/rtmidi/index.html"> RtMidi homepage.</a>
</p>

@subsection tuio_protocol_sec The TUIO protocol

<p><a href="http://www.tuio.org/">TUIO</a> is an open framework that defines a common protocol and API for tangible multitouch
surfaces.<br />
The TUIO protocol allows the transmission of an abstract description of interactive surfaces, including touch events and object states.
</p><p>
For further info about TUIO, please read the paper "TUIO: A Protocol for Table-Top Tangible User Interface" by M. Kaltenbrunner,
T. Bowermann, R. Bencina and E. Costanza.
</p>

@subsubsection tuio_osc_protocol_sec TUIO and OSC

<p>
Technically TUIO is based on <a href ="http://opensoundcontrol.org/"> Open Sound Control </a>, an emerging standard for interactive
environments (not only limited to musical instrument control).
<p></p>
TUIO protocol encodes control data from a tracker application, ReacTIVision, and sends it to any client application that is capable
of decoding the protocol.<br />
</p>

@subsubsection reactivision_framework_sec TUIO, reacTIVision and ReacTable

<p>
<a href="http://reactivision.sourceforge.net/">ReacTIVision</a> is an open source, cross-platform computer vision framework
for the fast tracking of fiducial markers and finger multi-touch onto physical surfaces.<br />
It was mainly designed as a toolkit for the development of table-based tangible user interfaces and interactive
surfaces with TUIO protocol.
</p><p>
This framework has been developed by Martin Kaltenbrunner and Ross Bencina at the Music Technology Group at the Universitat
Pompeu Fabra in Barcelona, Spain. ReacTIVision was designed as the underlying sensor component of the
<a href="http://www.reactable.com/">ReacTable</a>, a tangible modular synthesizer.<br /></p>

<p>We are building our own Reactable, not to use as a synthesizer, but just to control the sound generation parameters of
BCT synthesis system (remember: MIDI to trigger, TUIO to control).</p>

@image latex reactivision_reactable.png "reacTIVision and ReacTable framework diagram" width=280px

@subsubsection tuio_cpp_framework_sec TUIO C++ framework, a C++ implementation of the TUIO standard

<p>
In our project we used TUIO C++ framework, developed by Kaltenbrunner, in order to be able to receive TUIO from
Reactable/ReacTIVision.<br />
Our software receives TUIO messages through TuioInputDevice, the class implementing the TuioListener, then generates
FiducialObjects, which can be freely routed.
</p><p>
Here is a small scheme illustrating this 3rd party framework working.
</p>

@image latex tuio_schema.png "TUIO internal routing schema" width=280px

<p>
For further info please visit the <a href="http://www.tuio.org/">TUIO homepage</a> and TUIO C++ Reference Implementation.
</p>

*/

// -------------- Start Basic concepts page

/**
@page basic_concepts_page Basic concepts and models used in KetaRoller

<p>
KetaRoller uses some advanced techniques in conjunction with Qt to achieve some of its advanced
features, such as runtime data introspection, data routing, non strongly-typed methods and such.
</p>

@section plugin_factory_model_sec The plugin factory model

<p>
In KetaRoller, every routing component, except for InputPort, is a plugin which is dynamically loaded at runtime
if needed. However, given that most of the times you need to load more than an instance of a single plugin (this is
especially true for ports), exporting the main class itself as a plugin wouldn't have worked, as the exported symbol
could be loaded from the shared library only once, thus generating a single instance.
</p><p>
For this reason, an helper class has been created, AbstractPluginFactory. This class is what gets really exported, and
allows to create n instances of the plugin on demand. This mechanism is internal and completely transparent to both the
final user of the library and programmer who wants to implement a new plugin.
</p><p>
If you are using KetaRoller in your application, PluginLoader will take care of all the needed magic for getting you
an instance of the requested class ready to be used.
</p><p>
If you are implementing a new plugin, you just have to take care of implementing the main class: the factory will be
autogenerated by the build system through a cmake macro which handles the factory creation. This is explained in detail
in @ref create_plugins_cmake_sec "Creating plugins - Adding the necessary bits to the build system"
</p>


@section routing_model_sec Routing in KetaRoller

<p>
KetaRoller uses a 4-phase, modular routing to ensure the maximum flexibility for the programmer, without forgetting
the ease of use. It consists of four main components:
</p>

<ul>
    <li>InputDevice: The first element in the chain. It has to be reimplemented in a plugin. It takes care of
        validating ports and sending data to the correct input ports. It can contain an arbitrary number of
        InputPorts. Usually, it's an implementation of a real world device, such as reactivision.</li>
    <li>InputPort: Ports which takes care of opening a sort of tunnel from an InputDevice to an OutputDevice. An
        input port can be associated to a single InputDevice, and connected to an arbitrary number of OutputPorts.
        It takes care of routing the data to the output ports.</li>
    <li>OutputPort: Ports which takes care of receiving data and streaming it to its associated device. It has to
        be reimplemented in a plugin. It can be connected to a single InputPort and to a single OutputDevice. The
        port can work as a transparent bridge such as InputPort, or do some processing before streaming the data to
        the device. It's up to the programmer to decide how to implement this - however, it does not affect usage
        of the library.</li>
    <li>OutputDevice: The last element in the chain. It has to be reimplemented in a plugin. It takes care of
        validating ports and receiving data from its OutputPorts. It can contain an arbitrary number of
        OutputPorts. Usually, it's an implementation of a real world output device, such as a synthesizer.</li>
</ul>

<p>
So, a signal received from an InputDevice is routed to an OutputDevice through Ports. It's up to the programmer to decide
what ports should represent: usually, each port represents a single mean of communication of the device - for example, a
TUIO fiducial or a MIDI channel - but you might decide to use a single port to route all the traffic.
</p><p>
This architecture aims to provide a full loosely coupled system for routing signals, which is not even bound to what
a Port/Device combination supports: the developer is completely in control of each and every connection between Ports and Devices.
To the bottom line: the developer can couple any combination of devices. Here is a small schema of the routing chain:
</p>
@image latex routing_chain_graph.png "KetaRoller's routing chain" width=250px
<p>
When using the library and not implementing a plugin, the routing phase is started whenever the device receives data and it's
all processed internally - so you have nothing to do except connecting ports and associating them to devices.
</p>

@section generic_argument_model_sec The Generic Argument model

<p>
KetaRoller uses Qt's metaobjects capabilities to let different ports exchange arbitrary data in an
abstract way. Instead of using reimplementations of strongly-typed functions, KetaRoller uses QGenericArgument
in conjunction with QMetaObject::invokeMethod to call a callback defined in the plugin reimplementation with
the correct argument. Let's see an example to understand how this works.
</p><p>
Let's assume we are implementing an OutputPort, and our Input/Output chain in done through a custom data type
defined by \c MyDataType.
As explained in @ref creating_output_port_plugin_sec "creating an OutputPort",
we need to implement a function named receiveData in our class, which would look like:
</p>

@code
class MyOutputPort : public KetaRoller::OutputPort
{
    Q_OBJECT
public:
    MyOutputPort(QObject *parent = 0);
    virtual ~MyOutputPort();

public slots:
    void receiveData(const MyDataType &type);
}
@endcode

Done this, we'll need to declare MyDataType as a metatype known to Qt's metaobject system. To do that, we need to put
the following declaration

@code
Q_DECLARE_METATYPE(MyDataType)
@endcode

in an header of our project - be it the same header of the output port or (even better) the header of the file where the
type is defined.
<p>
This is enough to get our system working. Let's see what happens when calling the following snippet on an input port
connected to an instance of the output port we just created.
</p>

@code
MyDataType data = MyDataType::createNewFromRandomArguments();
inputPort->putData(Q_ARG(MyDataType, data));
@endcode

<p>
As you see, generating QGenericArgument happens through the Q_ARG macro, which accepts the type itself, and the instance
we want to pass as the argument. Internally, InputPort uses Qt's runtime introspection through QMetaObject::invokeMethod
to call the method with the correct signature on the receiver object.
</p><p>
Obviously, this method will work only if the signature of the slot corresponds to the type passed to Q_ARG(). For this
reason, it's impossible for a port to receive a type of data which does not know how to handle. This adds additional security
to the whole process, making the port not strongly-typed, but still type-safe on reception.
</p>

*/

// -------------- Start Usage page

/**
@page ketaroller_usage_page How to use KetaRoller in your application

<p>
Using KetaRoller in your application is extremely simple. Some examples are already provided in tests/manual, but this page
will explain how to connect a TUIO InputDevice and a MIDI InputDevice to an output device which we will name "SoundDevice" and
will assume existent, working, and accepting both MIDI and TUIO OutputPorts. Let's see how to do this.
</p>

@section instantiating_objects_usage_sec Instantiating the needed objects through PluginLoader and connecting the ports

<p>
First of all, we'll need to create our devices. We will assume an instance of our output device has already been created.
</p><p>
We want to create a MIDI device and a TUIO device, 3 TUIO ports (both input and output) and a single MIDI port.
To do this, we need to use PluginLoader. PluginLoader is the main entry point for creating objects from plugins. Let's
see it in action (m_tuioOutputs is a QHash<OutputPort*, int>, and so is m_tuioInputs):
</p>

@code
using namespace KetaRoller;

m_tuioInputDevice = PluginLoader::instance()->loadInputDevice(KetaRoller::PluginLoader::TuioType);
m_midiInputDevice = PluginLoader::instance()->loadInputDevice(KetaRoller::PluginLoader::MIDIType);

m_outputDevice = new SoundDevice();

for (int i = 0; i < 3; ++i) {
    OutputPort *port = PluginLoader::instance()->loadOutputPort(KetaRoller::PluginLoader::TuioType);
    m_outputDevice->addIncomingPort(port);
    m_tuioOutputs.insert(port, i);
}

m_midiOutput = PluginLoader::instance()->loadOutputPort(KetaRoller::PluginLoader::MIDIType);
m_outputDevice->addIncomingPort(m_midiOutput);

for (int i = 0; i < 3; ++i) {
    QVariantMap args;
    args.insert("TuioFiducialID", i);

    KetaRoller::InputPort *input = new InputPort(KetaRoller::Port::TUIOType, args);

    m_tuioInputDevice->addOutgoingPort(input);

    input->addOutput(m_outputs.key(i));

    m_tuioInputs.insert(input, i);
}

m_midiInput = new InputPort(KetaRoller::Port::MIDIType);
m_midiInput->addOutput(m_midiOutput);
@endcode

<p>As you can see, it's very easy to use PluginLoader to load the needed instances. InputPort, though, acts as a
transparent proxy, hence it's not reimplemented anywhere and can be created as a standard object, specifying the port
type.
</p><p>
While initializing our objects, we also connected the ports through InputPort::addOutput.
</p>

@section finalizing_usage_sec Maintainance of the created chain

Once the initialization has been completed, the chain is already working by itself: the InputDevices take care of routing
any input signal received through their ports, and the OutputDevice processes them as it should. However, you can monitor
the ports through portAdded and portRemoved signals, and disconnect them. It is advised to disconnect the ports through InputDevice
unless you have specific needs. Please refer to the class documentation of InputDevice to learn more on that.



*/

// -------------- Start Create plugins page

/**
@page creating_plugins_page How to create new plugins for KetaRoller

<p>
Creating new plugins for KetaRoller is easy. There should be a plugin for each of the three reimplementable classes (InputDevice,
OutputDevice and OutputPort). This section will cover how to create a plugin for each of this special cases. It is assumed that
you are confident with basic CMake and basic plugin concepts.
</p>

@section generic_plugin_info_sec Things to consider when creating a plugin

<p>
Differently from other Qt plugins, you <b>MUST NOT</b> use the Q_EXPORT_PLUGIN or Q_EXPORT_PLUGIN2 macro. This is automatically
done by the autogenerated files we'll talk about later in @ref create_plugins_cmake_sec "Adding the necessary bits to the build system".
</p><p>
Also, if you're not yet familiar with @ref generic_argument_model_sec "the generic argument model", please make sure to read the
related section before starting to code.
</p>

@section creating_input_device_plugin_sec Creating an InputDevice

<p>
To create an input device plugin, you need to reimplement KetaRoller::InputDevice in your class.
This is how the (basic) TUIO input device looks:
</p>

@code
class TuioInputDevice : public KetaRoller::InputDevice, public TUIO::TuioListener
{
    Q_OBJECT
    Q_INTERFACES(KetaRoller::InputDevice)

public:
    TuioInputDevice(QObject* parent = 0);
    virtual ~TuioInputDevice();

    virtual void addTuioCursor(TUIO::TuioCursor* tcur);
    virtual void addTuioObject(TUIO::TuioObject* tobj);

protected:
    virtual void init(const QVariantMap& args = QVariantMap());
    virtual bool validatePort(KetaRoller::InputPort* port);
};
@endcode

<p>Remember to use Q_INTERFACES. You probably want to reimplement init() to perform initialization on your plugin, and you
need to reimplement validatePort() to allow your device to accept only supported ports.
</p><p>
@c addTuioCursor is a TUIO specific callback, in which you need to create the data object and stream it to the correct port.
This is completely up to the device implementation: so inside your device you will need to call InputPort::putData on the correct
port to make the chain work correctly.
</p>

@section creating_output_port_plugin_sec Creating an OutputPort

<p>
To create an output port plugin, you need to reimplement KetaRoller::OutputPort in your class. Additionally, you will need to
implement an additional function as a <b>public slot</b> named @c receiveData. Failure in declaring it as a public slot
or with the correct name will prevent your plugin from working. This is how the (basic) TUIO output port looks:
</p>

@code
class TuioOutputPort : public KetaRoller::OutputPort
{
    Q_OBJECT
    Q_INTERFACES(KetaRoller::OutputPort)
public:
    TuioOutputPort(QObject *parent);
    virtual ~TuioOutputPort();

public slots:
    void receiveData(const FiducialObject &message);

};
@endcode

<p>Remember to use Q_INTERFACES. Have a look at how receiveData is implemented here - FiducialObject is the type which is
used in the TUIO message chain.
</p><p>
In receiveData, you will need to (eventually) process the received data and (eventually) stream it to the device. This is
done by calling OutputPort::sendDataToDevice(). Remember that you need explicitely to call this function whenever needed.
</p>

@section creating_output_device_plugin_sec Creating an OutputDevice

<p>
To create an output device plugin, you need to reimplement KetaRoller::OutputDevice in your class. Additionally, you will need to
implement an additional function as a <b>public slot</b> named @c newDataFromPort. Failure in declaring it as a public slot
or with the correct name will prevent your plugin from working. This is how a (basic) sound output device looks:
</p>

@code
class SoundOutputDevice : public KetaRoller::OutputDevice
{
    Q_OBJECT
    Q_INTERFACES(KetaRoller::OutputDevice)
public:
    SoundOutputDevice(QObject* parent = 0);
    virtual ~SoundOutputDevice();

    virtual void init(const QVariantMap& args = QVariantMap());
    virtual bool validatePort(KetaRoller::OutputPort* port);

public slots:
    void newDataFromPort(KetaRoller::OutputPort *port, const FiducialObject &obj);

};
@endcode

<p>Remember to use Q_INTERFACES. Have a look at how @c newDataFromPort is implemented here - FiducialObject is the type which is
used in the TUIO message chain. Also, remember that the first argument should @b ALWAYS be KetaRoller::OutputPort* - complete
with namespace in the exported symbol.
</p><p>
In @c newDataFromPort, you have to process the data which you received from the specified port as you please.
</p>

@section create_plugins_cmake_sec Adding the necessary bits to the build system

@note This applies to all kinds of plugins

<p>
KetaRoller features a very easy method to create plugins through CMake. A CMake macro named \c add_ketaroller_plugin is provided
to export plugins. This macro autogenerates a PluginFactory for your plugin; you just need to add the generated file to your
project's sources to make it work. This is how TUIO's buildsystem looks like:
</p>

@code
include_directories(
    ${CMAKE_CURRENT_BINARY_DIR}
    ${CMAKE_CURRENT_SOURCE_DIR}
)

include(KetaRollerPlugin)

add_ketaroller_plugin("TUIO" "TuioInputDevice.h" "InputDevice" "TuioInputDevice")
set(tuio_input_device_plugin_SRCS
    TuioInputDevice.cpp
    FiducialObject.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/TUIOInputDeviceFactory.cpp
)

automoc4_add_library(ketaroller_tuio_input_device SHARED ${tuio_input_device_plugin_SRCS})
target_link_libraries(ketaroller_tuio_input_device ketaroller tuio ${QT_QTGUI_LIBRARY})
@endcode

<p>
The macro takes 4 arguments, in order:

<ul>
    <li>The name of the plugin, which will be the prefix of the generated file. In this case, @c TUIO .</li>
    <li>The header file containing the plugin class itself, so in this case the file containing TuioInputDevice,
        @c TuioInputDevice.h .</li>
    <li>The class we are reimplementing @b WITHOUT the KetaRoller namespace, in this case @c InputDevice .</li>
    <li>The name of the class of our plugin, in this case @c TuioInputDevice .</li>
</ul>

So the name of the generated file is $FIRSTARGUMENT$THIRDARGUMENTFactory.cpp, and it is generated inside
${CMAKE_CURRENT_BINARY_DIR}. So adding it to your project's sources is enough to have your plugin ready.
</p>

@note Please note that the autogenerated files already include Q_EXPORT_PLUGIN2, so you should not use it in your sources.
*/

// -------------- Start Plugin specific documentation page

/**
@page plugin_specific_documentation_page Plugin-specific documentation (arguments, advices...)

<p>
In this page the specific usages of the MIDI and TUIO plugins will be described
</p>

@section plugins_init_arguments_sec Plugin arguments

<p>Some plugins need additional arguments when created. Follows a list of the valid keys to pass to args with the expected value
for both plugins.</p>

@subsection tuio_plugins_init_arguments_sec TUIO plugins

@subsubsection tuio_input_port_init_arguments_sec Input Port

<ul>
    <li>@c TuioFiducialID : Represents the ID of the fiducial this port will listen to. Value should be an int > 0. <b>This
        parameters is compulsory</b></li>
</ul>
*/
